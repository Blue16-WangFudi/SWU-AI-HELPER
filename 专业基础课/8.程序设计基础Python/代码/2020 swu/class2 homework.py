#(1):What is the invention of chess worth? 
'''
There is a popular myth about the man who invented chess. 
The local ruler was sopleased with the invention that he offered the inventor a great reward in gold. 
The inventor suggested an alternative reward: he would get one grain of wheat on the first square of the chess board,
two grains on the second square,four on the third, eight on the fourth, etc., doubling the number of grains each time.
The ruler saw that this must be a much better deal for him, and he accepted. The board has 64 squares.
Write a program to determine the following: 
(a) How many total grains of wheat did the ruler have to pay the inventor? 
(b) A wheat grain weighs approximately 50 mg. How much did the wheat weigh? 
(c) Pick a region (state, country, etc.) and determine how deeply that region would be covered with that quantity of wheat.
Prompt for the area of the region and then output the depth, including the units you use.
国际象棋的发明价值是什么？
关于发明象棋的人有一个流行的神话。 当地统治者对这项发明感到满意，以至于他为发明者提供了丰厚的金币奖励。
发明人提出了另一种奖励：他将在棋盘的第一个正方形上获得一粒小麦，在第二个正方形上获得两粒小麦，在第二个正方形上获得四粒小麦，
在第四个正方形上获得八粒小麦，以此类推，每次将谷物数量加倍 。
统治者认为这对他来说一定是更好的选择，他接受了。 木板有64个正方形。 编写一个程序来确定以下内容：
（a）统治者必须付给发明人多少小麦总麦粒？
（b）小麦籽粒重约50毫克。 小麦重了多少？
（c）选择一个地区（州，国家等），并确定该数量的小麦将覆盖该地区的深度。 提示该区域的面积，然后输出深度，包括您使用的单位。
'''
'''
#Question A:
value=1
total_quantity=1
for i in range(1,64):
    value=value*2
    total_quantity+=value
print('统治者必须付给发明人'+str(total_quantity)+'粒小麦总麦粒。')

#Question B:
unit_weight=50
wheat_weight=total_quantity*unit_weight/1000000
print('小麦重'+str(wheat_weight)+'吨')

#Question C:
#根据网络数据，一吨小麦的体积约为1.2立方米
region=input('输入你选择的区域：')
size=float(input('输入你所选择的区域的面积（以平方千米为单位）：'))
unit_volumn=1.2
depth=(wheat_weight*1.2/10**9)/size
print(str(wheat_weight)+'吨重的小麦可覆盖'+region+'的深度为'+str(depth)+'千米')
'''
#(2)2.2.15 Hailstone Sequence Example
'''The Collatz conjecture is an unsolved mathematical conjecture from 1937 that makes for
an interesting programming example. The conjecture is that given the following formula
and an initial positive integer, the generated sequence always ends in 1. Although this has
been shown to be true for large initial integers (approximately 2.7 × 1016), it has not yet
been proven true for all. It is an active research area with a new proof recently submitted for
publication but later withdrawn. The sequence is also called the hailstone sequence because
the numbers bounce up and down like hail until they converge to 1. Our task is to write a
program to generate the hailstone sequence.
The hailstone formula is as follows:
 If the number is even, divide it by 2.
 If the number is odd, multiply by 3 and add 1.
 When the number reaches 1, quit.
The sequence is formed by applying the formula to the initial number and then
repeatedly to each number generated by the formula. The result is a sequence of integers
ending at 1 (if you don’t stop at 1, what will happen?). For example, if you start with 5, you
get the following sequence: 5, 16, 8, 4, 2, 1.
We will create a program so you can try your hand at it. We will also output the length
of the sequence.
Determining whether a number is even or odd integer can be done using the remainder
operator (%). If we divide a number by 2 and the remainder is 0, the number is even.
Otherwise it is odd. In particular:
if number % 2 == 1:
print(number, "is odd")
else:
print(number, "is even")
Because 1 is considered to be True for a Boolean expression, the Boolean expression
number % 2 == 1 is often shortened to simply number % 2, as in:
if number % 2:
print(number, "is odd")
else:
print(number, "is even")
With that notation in hand, let’s apply the hailstone formula repeatedly to generate a
sequence (Code Listing 2.25).
2.2.15冰雹序列示例
Collat​​z猜想是1937年以来尚未解决的数学猜想，
一个有趣的编程示例。猜想是给定以下公式
和一个初始正整数，生成的序列始终以1结尾。
对于大的初始整数（大约2.7×1016）已证明是正确的，但尚未
被证明对所有人都是正确的。这是一个活跃的研究领域，最近提交了新证据
出版物，但后来撤回。该序列也称为冰雹序列，因为
这些数字像冰雹一样上下波动，直到收敛到1。我们的任务是编写一个
程序生成冰雹序列。
冰雹公式如下：
如果数字为偶数，则将其除以2。
如果数字是奇数，请乘以3并加1。
当数字达到1时，退出。
该序列是通过将公式应用于初始数字然后形成的
反复给公式生成的每个数字。结果是整数序列
结束于1（如果您不止于1，将会发生什么？）。例如，如果您从5开始，
得到以下顺序：5、16、8、4、2、1。
我们将创建一个程序，以便您可以尝试一下。我们还将输出长度
的顺序。
可以使用余数来确定数字是偶数还是奇数整数
运算符（％）。如果我们将数字除以2，而余数为0，则数字为偶数。
否则，这很奇怪。尤其是：
如果数字％2 == 1：
打印（数字，“是奇数”）
其他：
打印（数字，“偶数”）
因为对于布尔表达式，将1视为True，所以布尔表达式
数字％2 == 1通常缩短为数字％2，如：
如果数字％2：
打印（数字，“是奇数”）
其他：
打印（数字，“偶数”）
有了这个符号后，让我们重复应用冰雹公式以生成一个
序列（代码清单2.25）。
'''
number=int(float(input('输入一个初始正整数：')))
n=0
list=[]
while number!=1:
    n+=1
    if number%2==0:
        number=number/2
        list.append(number)
    else:
        number=number*3+1
        list.append(number)
print('sequence is '+' '.join('%d' %id for id in list))
print('the length of the sequence is '+str(len(list)))
print(n)
